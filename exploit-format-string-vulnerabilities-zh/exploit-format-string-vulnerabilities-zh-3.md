# 三、格式化字符串漏洞

格式化字符串漏洞的通常分类是“通道问题”。如果二类不同的信息通道混合为一个，并且特殊的转义字符或序列用于分辨当前哪个通道是激活的，这一类型的漏洞就可能出现。多数情况下，通道之一是数据通道，它不会解析，只会复制，而另一个通道是控制通道。

虽然对于其本身来说并不是件坏事，如果攻击者能够提供用于某个通道的输入，它可能很快成为严重的安全问题。通常存在错误的转义，或者反转义的途径，或者忽视了某个层面，就像格式化字符串漏洞中那样。所以我们总结一下：通道问题本身没有任何漏洞，但是它们使得 bug 可以利用。

为了展示它背后的普遍问题，这里是一个常见通道问题的列表：

| 场景 | 数据通道 | 控制通道 | 安全问题 |
| --- | --- | --- | --- |
| 电话系统 | 声音或数据 | 控制音调 | 线路控制 |
| PPP 协议 | 传输数据 | PPP 命令 | 流量放大 |
| 栈 | 栈数据 | 返回地址 | 返回地址控制 |
| Malloc 缓冲区 | Malloc 数据 | 管理信息 | 内存写入 |
| 格式化字符串 | 输出字符串 | 格式化参数 | 格式化函数控制 |

回到特定的格式化字符串漏洞，有两种典型的场景，其中产生了格式化字符串漏洞。

第一类（Linux rpc.statd 和 IRIX telnetd 中）。漏洞存在于`syslog`的第二个参数中。格式化字符串部分是用户提供。

```c
char tmpbuf[512];

snprintf (tmpbuf, sizeof (tmpbuf), "foo: %s", user); 
tmpbuf[sizeof (tmpbuf) - 1] = ’\0’; 
syslog (LOG_NOTICE, tmpbuf);
```

第二类（wu-ftpd 和 Qualcomm Popper QPOP 2.53 中）。部分由用户提供的字符串简介传给了格式化函数。

```c
int Error (char *fmt, ...);

... 
int someotherfunc (char *user) { 
    ...
    Error (user); 
    ...
} 
...
```

虽然第一类漏洞能够由自动化工具安全监测（例如 pscan 或 TESOgcc），只有工具被告知函数`Error`用作格式化函数，第二类漏洞才能检测出来。

> 但是，你可以自动化识别源码中的额外格式化函数，以及它们的参数的过程，所以总之，寻找格式化字符串的过程可以完全自动化。你甚至可以归纳出，如果有这样的工具来完成这件事，并且它没有在你的源码中发现格式化字符串漏洞，你的源码就没有这类漏洞。这不同于缓冲区溢出漏洞，其中即使由资深审计者手动审计了源码，还是会错过漏洞，并且没有可靠的方式来自动化找出它们。

## 3.1 我们能够控制什么？

通过提供格式化字符串，我们就能够控制格式化函数的行为。我们现在需要检验我们具体能够控制什么，以及如何使用它来扩展这个对进程的部分控制，来完全控制执行流。

## 3.2 使程序崩溃

使用格式化字符串漏洞的简单攻击，就是使进程崩溃。这对于某些事情是实用的，例如使守护进程崩溃，它会转储核心，并且在核心转储中有一些有用的数据。或者在一些网络攻击中，让一个服务无法响应十分有用，例如 DNS 伪造。

但是，在使其崩溃中有一些趣味。几乎所有 UNIX 系统中，内核都会检测非法指针访问，并且进程会接收到`SIGSEGV`信号。通常程序会终止并转储核心。

通过利用格式化字符串，我们可以轻易触发一些无效指针访问，通过仅仅提供像这样的格式化字符串：

```c
printf ("%s%s%s%s%s%s%s%s%s%s%s%s");
```

由于`%s`展示某个地址中的内存，这个地址位于栈上，栈上也储存了大量其他数据。我们就有很大机会来从非法地址服务数据，这个地址并没有映射。同时，多数何世华函数的实现提供了`%n`参数的功能，他可以用于向栈上的地址写入。如果它执行了几次，也一定会产生崩溃。

## 3.3 查看进程内存

入股哦我们可以查看格式户函数的回复 -- 也就是输出字符串 -- 我们就可以从中收集有用信息，因为它是我们所控制的行为的输出。而且我们可以使用这个结果，来获得我们的客户端字符串做了什么，以及进程的布局是什么样的概览。

这对于很多东西都很使用，例如为真正的利用寻找正确的偏移，或者仅仅是重新构造目标进程栈帧。

### 3.3.1 查看栈

我们可以展示栈内存的一些部分，通过像这样使用格式化字符串：

```c
printf ("%08x.%08x.%08x.%08x.%08x\n");
```

这可以工作，因为我们让`printf`函数来从栈中获取五个参数，并将其展示为 8 位填充的十六进制数值。所以可能的输出是：

```
40012980.080628c4.bffff7a4.00000005.08059c04
```

这是栈内存的部分转储，从当前的栈底一直到栈顶 -- 假设栈向低地址增长。取决于格式化字符传缓冲区的大小，以及输出缓冲区的大小，使用这种技巧，你可以或多或少重构栈内存的一部分。在一些情况下，你甚至可以获取整个栈内存。

栈的转储提供了关于程序流以及函数局部变量的重要信息，并且可能对于寻找正确偏移以便成功利用有所帮助。

### 3.3.2 查看任何地址的内存

我们也可以查看不同于栈内存的任意地址。为此，我们需要让格式化函数从我们可以提供的某个地址展示内存。这就有两个问题：首先，我们需要找到一个格式化字符串，它将某个地址（传值）用作栈的参数，并且展示其中的内存，并且我们需要提供这个地址，我们在第一种情况中足够幸运，由于`%s`参数就是干这个的，它展示内存 -- 通常是 ASCIIZ 字符串 -- 从栈上提供的地址。所以剩下的问题是，如何将这个栈上的地址放到正确的位置上。

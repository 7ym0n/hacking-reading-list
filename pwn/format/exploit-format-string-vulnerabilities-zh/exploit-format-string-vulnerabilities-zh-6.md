# 六、特殊案例

有一些可以利用的特定场景，不需要了解所有偏移，或者你可以使利用更加简单，直接，最重要的是：可靠。这里我列出了一些利用格式化字符串漏洞的常见方法。

## 6.1 替代目标

受基于栈的缓冲区溢出的较长历史的影响，很多人认为，覆盖栈上的返回地址是控制进程的唯一方式。但是如果我们利用格式化字符串漏洞，我们不能准确知道我们的缓冲区在哪里，并且我们可以覆盖另外一些东西。常见的基于栈的缓冲区溢出只能覆盖返回地址，因为它们也存储在栈上。但是使用格式化函数，我们可以覆盖内存中的任意地址，让我们能够修改整个可写入的进程空间。

因此，检验其它部分或完全控制被利用程序的方式，就很有意思了。在特定场景下，这可以产生一种更简单的利用方式 -- 我们之前看到 -- 或者可以用于绕过特定的保护。

我会在这里简单讨论一下替代的地址，并给出更深入的文章的引用。

### 6.1.1 GOT 覆盖

任何 ELF 二进制 [12] 的进程空间都包含一个特殊区段，叫做“全局偏移表”（GOT）。每个程序使用的库函数都在这里拥有一个条目，它包含一个真实函数的地址。这样是为了允许库在进程内存中简单地重定向，而不是使用硬编码的地址。在程序首次使用函数之前，条目包含运行时链接器（RTL）的地址。如果函数被程序调用，控制流就传递给了 RTL，并且函数的真实地址被解析并插入到 GOT。该函数的每个调用都将控制流直接传递给它自己，RTL 不再为该函数调用了。对于 GOT 利用的更加全面的概览，请参考 Lam3rZ 兄弟的不错的文章 [19]。

通过覆盖程序随后使用的函数的 GOT 条目，我们就可以利用格式化字符串漏洞，获取控制权，并跳到任何可执行的地址。不幸的是，这意味着任何基于栈的保护都会失效，它们检查了返回地址。

我们从覆盖 GOT 条目中获得的巨大优势，就是它独立于环境变量（例如栈），以及动态内存分配（堆）。GOT 条目的地址在每个二进制中是固定的，所以如果两个系统运行了相同的二进制，GOT 条目始终是同一地址。

你可以通过执行这个命令，看到 GOT 条目位于函数的哪里：

```
objdump --dynamic-reloc binary 
```

真实函数（或者 RTL 链接函数）的地址直接就是打印出的地址。

另一个非常重要的因素，为什么使用 GOT 条目来获取控制权，而不是返回地址，是代码的形式（在一些“安全”指纹守护程序中发现）：

```
syslog (LOG_NOTICE, user); 
exit (EXIT_FAILURE); 
```

这里你不能通过覆盖返回地址，来可靠地获取控制权。你可以尝试覆盖`syslog`自己的返回地址，但是更加可靠的方式就是覆盖`exit`函数的 GOT 条目，它会将执行流传递给你指定的地址，只要`exit`被调用。

> 译者注：动态链接时，程序会调用`libc`中的系统调用的封装。其它系统调用同理。

但是 GOT 技巧的最实用的优点，就是它易于使用，你只需要运行`objdump`，就能得到要覆盖的地址（`retloc`）。黑客们都懒得打字（除了粗心）。

### 6.1.2 DTORS

实用 GCC 编译的二进制包含一个特殊的析构器表区段，叫做`DTORS`。在真实的`exit`系统调用触发之前，在所有的常见清理操作完成之后，这里列出的析构器会调用。`DTORS`区段为以下格式：

```
DTORS: 0xffffffff 0x00000000 ...
```

其中第一项是一个计数器，它保存了下面函数指针的数量，如果列表为空则为负一（就像这里）。在所有 DTORS 区段的实现中，这个字段都是被忽略的。之后，在相对偏移`+4`的位置，就是清理函数的地址，以 NULL 地址终止。你可以仅仅将这个 NULL 指针覆盖为你的 shellcode 指针，并且你的 shellcode 就会在程序退出时执行。这一技巧更加复杂的介绍可以在 [17] 找到。

### 6.1.3 C 标准库的钩子

几个月之前，Splar Designer 介绍了一种新的技巧来利用`malloc`分配的内存中基于堆的溢出。它提倡覆盖 GNU C 库以及其他库中的钩子。通常，这个钩子有内存调试和性能工具使用，在应用使用`malloc`接口分配或释放内存时获取通知。有一些钩子，但是最常见的是`__malloc_hook`、`__realloc_hook`和`__free_hook`。通常它们设为 NULL，但是只要你使用指向你代码的指针覆盖了它，你的代码就会在`malloc`、`realloc`和`free`执行时调用。由于钩子通常用作调试工具，它们在真实函数执行之前调用。

关于`malloc`覆盖技巧的讨论在 Solar Designer 关于 Netspace JPEG 解码器漏洞的报告中提供。

## 6.1.4 `__atexit`结构

几个月之前，Kalou 介绍了一种利用 Linux 下静态链接二进制的方式，它利用了叫做`__atexit`的通用处理器，只要你的程序调用了`exit`，它就会执行。这允许程序建立很多处理器，它们会在退出时调用来释放资源。`__atexit`结构上的攻击的详细讨论，可以在 Pascal Bouchareines 的文章 [16] 中找到。




